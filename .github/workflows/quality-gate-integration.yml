name: Quality Gate Integration

on:
  workflow_run:
    workflows: 
      - "CI Optimized"
      - "Security Analysis"
      - "CodeQL Security Analysis"
      - "SonarCloud Analysis"
    types:
      - completed

jobs:
  aggregate-quality-results:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.event == 'pull_request'
    permissions:
      checks: read
      statuses: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get PR details
        id: pr-details
        uses: actions/github-script@v7
        with:
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: context.payload.workflow_run.head_branch,
              state: 'open'
            });
            
            if (prs.length === 0) {
              console.log('No open PR found for this branch');
              return null;
            }
            
            const pr = prs[0];
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_url', pr.html_url);
            return pr;

      - name: Aggregate Quality Results
        if: steps.pr-details.outputs.pr_number
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ steps.pr-details.outputs.pr_number }}';
            
            // Get all check runs for the PR
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.workflow_run.head_sha
            });
            
            // Get all status checks for the PR
            const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.workflow_run.head_sha
            });
            
            // Categorize results
            const qualityChecks = {
              security: {
                name: 'Security Checks',
                checks: checkRuns.check_runs.filter(run => 
                  run.name.includes('Security') || 
                  run.name.includes('CodeQL') ||
                  run.name.includes('Snyk') ||
                  run.name.includes('TruffleHog')
                ),
                status: 'unknown'
              },
              quality: {
                name: 'Code Quality',
                checks: checkRuns.check_runs.filter(run => 
                  run.name.includes('SonarCloud') ||
                  run.name.includes('lint') ||
                  run.name.includes('typecheck')
                ),
                status: 'unknown'
              },
              testing: {
                name: 'Testing & Coverage',
                checks: checkRuns.check_runs.filter(run => 
                  run.name.includes('test') ||
                  run.name.includes('coverage')
                ),
                status: 'unknown'
              },
              build: {
                name: 'Build & Deploy',
                checks: checkRuns.check_runs.filter(run => 
                  run.name.includes('build') ||
                  run.name.includes('deploy')
                ),
                status: 'unknown'
              }
            };
            
            // Calculate category statuses
            Object.keys(qualityChecks).forEach(category => {
              const categoryChecks = qualityChecks[category].checks;
              if (categoryChecks.length === 0) {
                qualityChecks[category].status = 'not_applicable';
                return;
              }
              
              const completed = categoryChecks.filter(check => check.status === 'completed');
              const successful = completed.filter(check => check.conclusion === 'success');
              const failed = completed.filter(check => 
                check.conclusion === 'failure' || check.conclusion === 'cancelled'
              );
              
              if (failed.length > 0) {
                qualityChecks[category].status = 'failed';
              } else if (successful.length === categoryChecks.length) {
                qualityChecks[category].status = 'passed';
              } else {
                qualityChecks[category].status = 'pending';
              }
            });
            
            // Generate quality gate summary
            const passedCategories = Object.values(qualityChecks).filter(cat => cat.status === 'passed').length;
            const failedCategories = Object.values(qualityChecks).filter(cat => cat.status === 'failed').length;
            const totalCategories = Object.values(qualityChecks).filter(cat => cat.status !== 'not_applicable').length;
            
            const overallStatus = failedCategories > 0 ? 'failed' : 
                                passedCategories === totalCategories ? 'passed' : 'pending';
            
            const statusEmoji = {
              'passed': '✅',
              'failed': '❌', 
              'pending': '⏳',
              'not_applicable': '➖'
            };
            
            // Create quality gate summary
            let summary = `## 🛡️ Quality Gate Results\n\n`;
            summary += `**Overall Status**: ${statusEmoji[overallStatus]} ${overallStatus.toUpperCase()}\n\n`;
            
            summary += `| Category | Status | Checks |\n`;
            summary += `|----------|--------|--------|\n`;
            
            Object.entries(qualityChecks).forEach(([key, category]) => {
              const emoji = statusEmoji[category.status];
              const checkCount = category.checks.length;
              summary += `| ${category.name} | ${emoji} ${category.status} | ${checkCount} checks |\n`;
            });
            
            summary += `\n### 📊 Summary\n`;
            summary += `- **Total Categories**: ${totalCategories}\n`;
            summary += `- **Passed**: ${passedCategories}\n`;
            summary += `- **Failed**: ${failedCategories}\n`;
            summary += `- **Success Rate**: ${totalCategories > 0 ? Math.round((passedCategories / totalCategories) * 100) : 0}%\n\n`;
            
            if (overallStatus === 'failed') {
              summary += `### ⚠️ Failed Checks\n`;
              Object.entries(qualityChecks).forEach(([key, category]) => {
                if (category.status === 'failed') {
                  const failedChecks = category.checks.filter(check => 
                    check.conclusion === 'failure' || check.conclusion === 'cancelled'
                  );
                  failedChecks.forEach(check => {
                    summary += `- **${check.name}**: ${check.conclusion} - [View Details](${check.html_url})\n`;
                  });
                }
              });
            }
            
            summary += `\n---\n*Quality gate results updated automatically by GitHub Actions*`;
            
            // Update or create PR comment
            try {
              // Find existing quality gate comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              const existingComment = comments.find(comment => 
                comment.body.includes('🛡️ Quality Gate Results')
              );
              
              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: summary
                });
                console.log('Updated existing quality gate comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summary
                });
                console.log('Created new quality gate comment');
              }
              
              // Set labels based on quality gate status
              const currentLabels = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              const qualityLabels = ['quality:passed', 'quality:failed', 'quality:pending'];
              const currentQualityLabels = currentLabels.data.filter(label => 
                qualityLabels.includes(label.name)
              );
              
              // Remove existing quality labels
              for (const label of currentQualityLabels) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label.name
                });
              }
              
              // Add new quality label
              const newLabel = `quality:${overallStatus}`;
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: [newLabel]
              });
              
              console.log(`Added label: ${newLabel}`);
              
            } catch (error) {
              console.error('Error updating PR comment or labels:', error);
            }

  update-project-board:
    runs-on: ubuntu-latest
    needs: aggregate-quality-results
    if: always()
    permissions:
      projects: write
      issues: read
    
    steps:
      - name: Update Project Board Status
        uses: actions/github-script@v7
        with:
          script: |
            console.log('Project board integration would update item status based on quality gate results');
            console.log('This requires additional GraphQL operations for full implementation');
            
            // Placeholder for project board status updates
            // In a full implementation, this would:
            // 1. Find the project item for this PR/issue
            // 2. Update status fields based on quality gate results
            // 3. Move items between columns based on overall status